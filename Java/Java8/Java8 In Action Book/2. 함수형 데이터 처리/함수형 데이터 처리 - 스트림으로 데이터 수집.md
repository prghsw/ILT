## 함수형 데이터 처리 - 스트림으로 데이터 수집

### 그룹화

- 데이터 집합을 하나 이상의 특성으로 분류해서 그룹화하는 것입니다.

1. 팩토리 메소드 Collectors.groupingBy

- 스트림의 각 몬스터에서 Monter.Type과 일치하는 모든 몬스터를 추출합니다.

  > ``` java
  >  Map<Monster.Type, List<Monster>> monsterByType =
  >     monster.stream().collect(groupingBy(Monster.getType));
  > ```
  >
  > - 결과
  >
  >   {DRAGON = [blue dragon, brass dragon, red dragon], ZOMBIE = [dummy, noisy],
  >
  >   OTHER = [shaman, snake]}

- ***스트림이 그룹화되는 것을 분류함수 (classification functions)라고 합니다.***

![그룹화 과정](https://github.com/prghsw/ILT/blob/master/Java/Java8/Java8%20In%20Action%20Book/2.%20%ED%95%A8%EC%88%98%ED%98%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%B2%98%EB%A6%AC/images/%EA%B7%B8%EB%A3%B9%ED%99%94%20%EA%B3%BC%EC%A0%95.png)

- 복잡한 분류 기준에서 그룹화를 처리합니다.

  > ``` java
  > public enum PowerLevel { POWER, POOWER, POOOWER}
  > 
  > Map<PowerLevel, List<Monster>> monsterByPowerLevel = monster.stream()
  >     .collect(
  > 		groupingBy(monster -> {
  >           if (monster.getPower() <= 400) {
  >               return PowerLevel.POWER;
  >           } else if (monster.getPower() <= 700) {
  >               return PowerLevel.POOWER;
  >           } else {
  >               return PowerLevel.POOOWER;
  >           }
  >         }));
  > ```

### 다수준 그룹화

- 항목을 다수준으로 그룹화 할 수 있습니다.

- Collectors.groupingBy는 일반적인 분류 함수와 컬렉터를 인수로 받습니다.

- 두 번째 기준을 정의는 부분에 groupingBy를 전달하여 두 수준으로 스트림의 항목을 그룹화 할 수 있습니다.

  > ``` java
  > Map<Monter.Type, Map<MonsterLevel, List<Monster>>> monsterByTypeMonsterLevel = menu.stream().collect(
  > 	groupingBy(Monster::getType,
  >     	groupingBy(monster -> {
  >             if (monster.getPower() <= 400) {
  >                 return MonsterLevel.POWER;
  >             } else if (monster.getPower() <= 700) {
  >                 return MonsterLevel.POOWER;
  >             } else {
  >                 return MonsterLevel.POOOWER;
  >             }
  >         })
  > 	)
  > );
  > ```
  >
  > - 결과
  >
  >   {DRAGON = {POWER=[blue dragon], POOWER=[red dragon], POOOWER=[brass dragon] }, 
  >
  >    ZOMBIE = {POWER=[dummy], POOWER=[noisy] },
  >
  >    OTHER = {POWER=[shaman], POOOWER=[snake] } }

![다 수준 그룹화 과정](https://github.com/prghsw/ILT/blob/master/Java/Java8/Java8%20In%20Action%20Book/2.%20%ED%95%A8%EC%88%98%ED%98%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%B2%98%EB%A6%AC/images/%EB%8B%A4%20%EC%88%98%EC%A4%80%20%EA%B7%B8%EB%A3%B9%ED%99%94%20%EA%B3%BC%EC%A0%95.png)

### 서브그룹으로 데이터 수집

- 첫 번째 groupingBy로 넘겨주는 컬렉터의 형식은 제한이 없습니다.

- groupingBy 컬렉터에 두번째 인수로 counting 컬렉터를 전달해서 몬스터의 수를 종류 별로 계산 할 수 있습니다.

  > ``` java
  > Map<Monster.Type, Long> typesCount = monster.stram().collect(
  > 						goupingBy(Monster::getType, counting()));
  > ```
  >
  > - 결과
  >
  >   {DRAGON=3, ZOMBIE=2, OTHER=2}

*** 한개의 인수를 갖는 goupingBy ( f )는 사실 gruopingBy (f, toList()) 의 축약형 입니다. ***

- 가장 강력한 몬스터를 찾습니다.

  > ``` java
  > Map<Monster.Type, Optional<Monster>> mostPowerByType =
  >     menu.stram()
  >     	.collect(groupingBy(Monster::getType,
  >                            maxBy(comparingInt(Monster::getPower()))));
  > ```
  >
  > - 결과
  >
  >   {DRAGON=Optional[brass dragon], ZOMBIE=Optional[noisy], OTHER=Optional[snake]}

*** 팩토리 메서드 maxBy가 생성하는 컬렉터의 결과 형식에 따라 맵의 값이 Optional 형식이 되었습니다. 하지만 실 데이터인 몬스터들 중 Optional.empty()를 값으로 갖는 것은 없습니다. 값이 없는 키는 맵에 추가 되지 않기 때문입니다. groupingBy 컬렉터는 스트림의 첫 번째 요소를 찾은 후에 그룹화 맵에 새로운 키를 게으르게 추가 합니다. 리듀싱 컬렉터가 반환하는 형식을 사용하는 상황이므로 굳이 Optional 래퍼를 사용할 필요가 없습니다. ***

### 컬렉터 결과를 다른 형식에 적용하기

- 그룹화 연산에서 맵의 모든 값을 Optional로 감쌀 필요가 없습니다.

- 팩토리 메서드 Collectors.collectingAndThen으로 컬렉터가 반환한 결과를 다른 형식으로 반환할 수 있습니다.

- Collectors.collectingAndThen은 적용할 컬렉터와 변환함수를 인수로 받아 다른 컬렉터를 반환합니다.

- maxBy로 만들어진 컬렉터가 감싸지는 컬렉터며 변환함수 Optional::get으로 반환된 Optional에 포함된 값을 추출 한다.

  ***리듀싱 컬렉터는 절때 Optional.empty()를 반환하지 않으므로 안전한 코드다.***

  > ``` java
  > Map<Monster.Type, Monster> mostPowerByType =
  >     menu.stram()
  >     	.collect(groupingBy(Monster::getType,
  >                        collectingAndThen(
  >                            maxBy(comparingInt(Monster::getPower)),
  >                        Optional::get)));
  > ```
  >
  > - 결과
  >
  >   {DRAGON=brass dragon, ZOMBIE=noisy, OTHER=snake}

![여러 컬렉터 중첩 과정](https://github.com/prghsw/ILT/blob/master/Java/Java8/Java8%20In%20Action%20Book/2.%20%ED%95%A8%EC%88%98%ED%98%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%B2%98%EB%A6%AC/images/%EC%97%AC%EB%9F%AC%20%EC%BB%AC%EB%A0%89%ED%84%B0%20%EC%A4%91%EC%B2%A9%20%EA%B3%BC%EC%A0%95.png)

### groupingBy와 함께 사용하는 다른 컬렉터 예제

- 메뉴에 있는 모든 요리의 칼로리 합계

  > ``` java
  > Map<Monster.Type, Integer> totalPowerByType =
  >     menu.stream().collect(groupingBy(Monster::getType,
  >                                        summingInt(Monster::getPower)));
  > ```

- 각 몬스터 형식에 존재하는 모든 PowerLevel값 매핑

  > ``` java
  > Map<Monster.Type, Set<PowerLevel>> powerLevelByType =
  >     menu.stream().collect(
  > 			groupingBy(Monster::getType, mapping(monster -> {
  >                 if (monster.getPower() <= 400) {
  >                     return MonsterLevel.POWER;
  >                 } else if (monster.getPower() <= 700) {
  >                     return MonsterLevel.POOWER;
  >                 } else {
  >                     return MonsterLevel.POOOWER;
  >                 }
  >             },
  >     		toSet())));
  > 	// toCollection을 이용하면 원하는 방식으로 결과를 제어 할 수 있다. 
  > 	// toCollection(HashSet::new))));
  > ```
  >
  > - 결과
  >
  >   {OTHER=[POOWER, POWER], DRAGON=[POOWER, POWER, POOOWER], ZOMBIE=[POOWER, POWER]}

### 분할

- 분할 함수(partitioning function)라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능입니다.

- 분할 함수는 불린을 반환하므로 맵의 키 형식은 Boolean입니다. 결과적으로 그룹화 맵은 최대 (참아니면 거짓의 값을 갖는) 두 개의 그룹으로 분류됩니다.

  > ``` java
  > Map<Boolean, List<Monster>> partitionedMonster =
  >     type.stream().collect(partitioningBy(Monster::isNamed)); // 분할함수
  > 
  > List<Monster> namedMonsters = partitionedMonster.get(true);
  > 
  > List<Monster> namedMonsters =
  >     type.stream().filter(Monster::isNamed).collect(toList());
  > ```
  >
  > - 결과
  >
  >   {false=[snake, dummy, blue dragon, red dragon],
  >
  >    true=[shaman, noisy, brass dragon]}

### 분할의 장점

- 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점이다.

- 컬렉터를 두 번째 인수로 전달 할 수 있는 오버로드된 버전의 partitioningBy 메서드도 있습니다.

  > ``` java
  > Map<Boolean, Map<Monster.Type, List<Monster>>> namedMonsterByType = 
  >     type.stream().collect(
  > 		partitioningBy(Monster::isNamed,
  >                       groupingBy(Monster::getType)));
  > ```
  >
  > - 결과
  >
  >   {false = {OTHER=[snake], DRAGON=[blue dragon, red dragon], ZOMBIE=[dummy]},
  >
  >    true = {OTHER=[noisy], DRAGON=[brass dragon], ZOMBIE=[shaman]}}

- 네임드가 아닌 것과 네임드 중에서 가장 강한 몬스터를 찾을 수 있습니다.

  > ``` java
  > Map<Boolean, Monster> mostPowerPartitionedByMonster =
  >     type.stream().collect(
  > 		partitioningBy(Monster::isNamed,
  >                       collectingAndThen(
  >                           maxBy(comparingInt(Monster::getPower)),
  >                       		Optional::get)));
  > ```
  >
  > - 결과
  >
  >   {false = snake, true = brass dragon}

### 숫자를 소수와 비소수로 분할하기

> - 소수인지 아닌지 판단하는 프레디케이트 구현
>
> ``` java
> public boolean isPrime(int candidate) {
>     return IntStream.range(2, candidate)
>         			.noneMatch(i -> candidate % i == 0);
> }
> 
> // 제곱근 이하의 수로 제한
> public boolean isPrime(int candidate) {
>     int candidateRoot = (int) Math.sqrt((double) candidate);
>     return IntStream.rangeClosed(2, candidateRoot)
>         			.noneMatch(i -> candidate % i == 0);
> }
> ```
>
> - 구현된 프레디케이트를 이용하여 소수와 비소수를 분류
>
> ``` java
> public Map<Boolean, List<Integer>> partitionPrimes(int n) {
>     return IntStream.rangeClosed(2, n).boxed()
>         			.collect(
>     					partitioningBy(candidate -> isPrime(candidate)));
> }
> ```

- Collectors 클래스의 정적 팩토리 메서드

​	**팩토리 메서드 / 반환방식 / 사용예제**

> **toList  / List<T> / 스트림의 모든 항목을 리스트로 수집**
>
> 활용 예 : List<Monster> monsters = monsterStream.collect(toList());
>
> **toSet / Set<T> / 스트림의 모든 항목을 중복이 없는 집합으로 수집**
>
> 활용 예 : Set<Monster> monsters = monsterStream.collect(toSet());
>
> **toCollection / Collection<T> / 스트림의 모든 항목을 공급자가 제공하는 컬렉션으로 수집**
>
> 활용 예 : Collection<Monster> monsters = monsterStream.collect(toCollection(), ArrayList::new);
>
> **counting / Long / 스트림의 항목 수 계산**
>
> 활용 예 : long howManyMonsters = monsterStream.collect(counting());
>
> **summingInt / Integer / 스트림의 항목에서 정수 프로퍼티값을 더함**
>
> 활용 예 : int totalPower = monsterStream.collect(summingInt(Monster::getPower));
>
> **averagingInt / Double / 스트림의 항목의 정수 프로퍼티의 평균값 계산**
>
> 활용 예 : double avgPower = monsterStream.collect(averagingInt(Monster::getPower));
>
> **summarizingInt / IntSummaryStatistics / 스트림 내의 항목의 최댓값, 최솟값, 합계, 평균 등의 정수 정보 통계를 수집**
>
> 활용 예 : IntSummaryStatistics monsterStatistics =
>
> ​														monsterStream.collect(summarizingInt(Monster::getPower));
>
> **joining / String / 스트림의 각 항목에 toString 메서드를 호출한 결과 문자열을 연결**
>
> 활용 예 : String shortMonster = monsterStream.map(Monster::getName).collect(joining(","));
>
> **maxBy / Optional<T> / 주어진 비교자를 이용해서 스트림의 최댓값 요소를 Optional로 감싼 값을 반환. 스트림에 요소가 없을때는 Optional.empty()를 반환**
>
> 활용 예 : Optional<Monster> strongtest =
>
> ​									monsterStream.collect(maxBy(comparingInt(Monster::getPower)));
>
> **minBy / Optional<T> / 주어진 비교자를 이용해서 스트림의 최솟값 요소를 Optional로 감싼 값을 반환. 스트림에 요소가 없을 때는 Optional.empty()를 반환**
>
> 활용 예 : Optional<Monster> weaktest =
>
> ​									monsterStream.collect(minBy(comparingInt(Monster::getPower)));
>
> **reducing / 리듀싱 연산에서 형식을 결정 / 누적자를 초깃값으로 설정한 다음에 BinaryOperator로 스트림의 각 요소를 반복적으로 누적자와 합쳐 스트림을 하나의 값으로 리듀싱**
>
> 활용 예 : int totalPower =
>
> ​									monsterStream.collect(reducing(0, Monster::getPower, Integer::sum));
>
> **collectingAndThen / 변환 함수가 형식을 반환 / 다른 컬렉터를 감싸고 그 결과에 변환 함수를 적용**
>
> 활용 예 : int howManyMonsters =
>
> ​									monsterStream.collect(collectingAndThen(toList(), List::size));
>
> **groupingBy / Map<K, List<T>> / 하나의 프로퍼티값을 기준으로 스트림의 항목을 그룹화하며 기준 프로퍼티값을 결과 맵의 키로 사용**
>
> 활용 예 : Map<Monster.Type, List<Monster>> monsterByType =
>
> ​									monsterStream.collect(groupingBy(Monster::getType));
>
> **partitioningBy / Map<Boolean, List<T>> / 프레디케이트를 스트림의 각 항목에 적용한 결과로 항목을 분할**
>
> 활용 예 : Map<Boolean, List<Monster>> namedMonsters = 
>
> ​									monsterStream.collect(partitioningBy(Monster::isNamed));

### Collector 인터페이스

> ``` java
> public interface Collector<T, A, R> {
>     Supplier<A> supplier();
>     BiConsumer<A, T> accumulator();
> 	Function<A, R> finisher();
> 	BinaryOperator<A> combiner();
> 	Set<Characteristics> characteristics();
> }
> 
> // Stream<T>의 모든 요소를 List<T>로 수집하는 ToListCollector<T>라는 클래스를 구현할 수 있습니다.
> public class ToListCollector<T> implements Collector<T, List<T>, List<T>>
> ```
>
> - T는 수집될 스트림 항목의 제네릭 형식입니다.
> - A는 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식입니다.
> - R은 수집 연산 결과 객체의 형식(항상 그런것은 아니지만 대개 컬렉션 형식)입니다.

### Collector 인터페이스의 메서드 살펴보기

*** supplier 메서드 : 새로운 결과 컨테이너 만들기 ***

- supplier 메서드는 빈 결과로 이루어진 Supplier를 반환해야 합니다.
- supplier는 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수입니다.

> ``` java
> public Supplier<List<T>> supplier() {
>     return () -> new ArrayList<T>();
> }
> 
> // 생성자 레퍼런스 전달 방법
> public Supplier<List<T>> supplier() {
>     return ArrayList::new;
> }
> ```

*** accumulator 메서드 : 결과 컨테이너에 요소 추가하기 ***

- accumulator 메서드는 리듀싱 연산을 수행하는 함수를 반환합니다.
- 스트림에서 n번째 요소를 탐색할 때 두 인수, 누적자(스트림의 첫 n-1개 항목을 수집한 상태)와 n번째 요소를 함수에 적용합니다.
- 함수의 반환값은 void, 요소를 탐색 하면서 적용하는 함수에 의해 누적자 내부 상태가 바뀌므로 누적자가 어떤 값일지 단정할 수 없습니다.

> ``` java
> public BiConsumer<List<T>, T> accumulator() {
>     return (list, item) -> list.add(item);
> }
> // 메서드 레퍼런스 이용 방법
> public BiConsumer<List<T>, T> accumulator() {
>     return List::add;
> }
> ```

*** finisher 메서드 : 최종 변환값을 결과 컨테이너로 적용하기 ***

- finisher 메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수를 반환해야 합니다.
- 누적자 객체가 최종 결과인 상황도 있습니다. 변환 과정이 필요하지 않으므로 항등 함수를 반환합니다.

> ``` java
> public Function<List<T>, List<T>> finisher() {
>     return Function.identity();
> }
> ```

*** combiner 메서드 : 두 결과 컨테이너 병합 ***

- 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의합니다.
- 스트림의 두 번째 서브파트에서 수집한 항목 리스트를 첫 번째 서브파트 결과 리스트의 뒤에 추가하면 됩니다.

![순차 리듀싱 과정의 논리적 순서](https://github.com/prghsw/ILT/blob/master/Java/Java8/Java8%20In%20Action%20Book/2.%20%ED%95%A8%EC%88%98%ED%98%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%B2%98%EB%A6%AC/images/%EC%88%9C%EC%B0%A8%20%EB%A6%AC%EB%93%80%EC%8B%B1%20%EA%B3%BC%EC%A0%95%EC%9D%98%20%EB%85%BC%EB%A6%AC%EC%A0%81%20%EC%88%9C%EC%84%9C.png)

> ``` java
> public BinaryOperator<List<T>> combiner() {
>     return (list1, list2) -> {
>         list1.addAll(list2);
>         return list1;
>     }
> }
> ```

- combiner 메서드를 이용하면 스트림의 리듀싱을 병렬로 수행할 수 있습니다.
- 스트림의 리듀싱을 병렬로 수행할 때 자바 7의 포크/조인 프레임워크와 Spliterator를 사용합니다.

![병렬화 리듀싱 과정에서 combiner 메서드 활용](https://github.com/prghsw/ILT/blob/master/Java/Java8/Java8%20In%20Action%20Book/2.%20%ED%95%A8%EC%88%98%ED%98%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%B2%98%EB%A6%AC/images/%EB%B3%91%EB%A0%AC%ED%99%94%20%EB%A6%AC%EB%93%80%EC%8B%B1%20%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C%20combiner%20%EB%A9%94%EC%84%9C%EB%93%9C%20%ED%99%9C%EC%9A%A9.png)

1. 스트림을 분할해야 하는지 정의하는 조건이 거짓으로 바뀌기 전까지 원래 스트림을 재귀적으로 분할 합니다. (보통 분산된 작업의 크기가 너무 작아지면 병렬 수행의 속도는 순차 수행의 속도보다 느려집니다. 일반적으로 프로세싱 코어의 개수를 초과하는 병렬 작업은 효율적이지 않습니다.)
2. 모든 서브스트림의 각 요소에 리듀싱 연산을 순차적으로 적용해서 서브스트림을 병렬로 처리할 수 있습니다.
3. 마지막에는 컬렉터의 combiner 메서드가 반환하는 함수로 모든 부분결과를 쌍으로 합칩니다. 분할된 모든 서브스트림의 결과를 합치면서 연산이 완료됩니다.

### Characteristics 메서드

- 컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환합니다.
- 스트림을 병렬로 리듀스할 것인지 그리고 병렬로 리듀스한다면 어떤 최적화를 선택해야 할지 힌트를 제공합니다.

*** 열거형 항목 ***

**UNORDERED**

- 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향을 받지 않습니다.

**CONCURRENT**

- 다중 스레드에서 accumulator 함수를 동시에 호출할 수 있으며 이 컬렉터는 스트림의 병렬 리듀싱을 수행할 수 있습니다.
- 컬렉터의 플래그에 UNORDERED를 함께 설정하지 않았다면 데이터 소스가 정렬되어 있지 않은(집합처럼 요소의 순서가 무의미한) 상황에서만 병렬 리듀싱을 수행 할 수 있습니다.

**IDENTITY_FINISH**

- finisher 메서드가 반환하는 함수는 단순히 identity를 적용할 뿐이므로 이를 생략할 수 있습니다.
- 리듀싱 과정의 최종 결과로 누적자 객체를 바로 사용할 수 있습니다. 누적자 A를 결과 R로 안전하게 형변환할 수 있습니다.

> ``` java
> public class ToListCollector<T> implements Collector<T, List<T>, List<T>> {
>     @Override
>     public Supplier<List<T>> supplier() {
>         // 수집 연산의 시발점
>         return ArrayList::new;
>     }
>     
>     @Override
>     public BiConsumer<List<T>, T> accumulator() {
>         // 탐색한 항목을 누적하고 바로 누적자를 고친다.
>         return List::add;
>     }
>     
>     @Override
>     public Function<List<T>, List<T>> finisher() {
>         // 항등 함수
>         return Function.indentity();
>     }
>     
>     @Override
>     public BinaryOperator<List<T>> combiner() {
>         // 두번째 콘텐츠와 합쳐서 첫번째 누적자를 고친다.
>         return (list1, list2) -> {
>             list1.addAll(list2);
>             // 변경된 첫번째 누적자를 반환한다.
>             return list1;
>         }
>     }
>     
>     @Override
>     public Set<Characteristice> characteristics() {
>         // 콜렉터의 플래그를 IDENTITY_FINISH, CONCURRENT로 설정한다.
>         return Collections.unmodifiableSet(EnumSet.of(
>         	IDENTITY_FINISH, CONCURRENT));
>     }
> }
> // 커스텀 컬렉터 사용
> List<Monster> monsters = monsterStream.collect(new ToListCollector<Monster>());
> ```



### 컬렉터 구현을 만들지 않고도 커스텀 수집 수행하기

- IDENTITY_FINISH 수집 연산에서는 Collector 인터페이스를 생성하지 않고 값을 얻을 수 있습니다.
- Stream은 세 함수 (supplier, accumulator, combiner)를 인수로 받는 collect 메서드를 오버로드하며 각각의 메서드는 Collector 인터페이스의 메서드가 반환하는 함수와 같은 기능을 수행합니다.

> ``` java
> List<Monster> monsters = monsterStream.collect(
> 								ArrayList::new,
> 								List::add,
> 								List::addAll)
> ```

- 적절한 클래스로 커스텀 컬렉터를 구현하는 편이 중복을 피하고 재사용성을 높이는 데 도움이 됩니다.
- 두 번째 collect 메서드로는 Characteristics를 전달 할 수 없습니다.
- collect 메서드는 IDENTIT

### 요약

1. collect는 스트림의 요소를 요약 결과로 누적하는 다양한 방법 (컬렉터라 불리는)을 인수로 갖는 최종 연산입니다.
2. 스트림의 요소를 하나의 값으로 리듀스하고 요약하는 컬렉터뿐 아니라 최솟값, 최댓값, 평균값을 계산하는 컬렉터 등이 미리 정의되어 있습니다.
3. 미리 정의된 컬렉터인 groupingBy로 스트림의 요소를 그룹화하거나, partitioningBy로 스트림의 요소를 분할 할 수 있습니다.
4. 컬렉터는 다수준의 그룹화, 불할, 리듀싱 연산에 적합하게 설계되어 있습니다.
5. Collector 인터페이스에 정의된 메서드를 구현해서 커스텀 컬렉터를 개발할 수 있습니다.
